require "atmos.env.pico"
val pico = require "pico"

;; Game configuration
val W = 350
val H = 350
val ENEMY_SPEED = 3000
val ENEMY_SPAWN_MS = 500

;; Player sprite (8x8 running person)
val G = @{ r=0x00, g=0xCC, b=0x00 }
val PLAYER_SPRITE = @{
    @{ nil, nil,   G,   G,   G,   G, nil, nil },
    @{ nil,   G,   G,   G,   G,   G,   G, nil },
    @{ nil, nil,   G,   G,   G,   G, nil, nil },
    @{ nil,   G,   G,   G,   G,   G,   G, nil },
    @{ nil, nil,   G,   G,   G,   G, nil, nil },
    @{ nil,   G, nil,   G,   G, nil,   G, nil },
    @{   G, nil, nil,   G,   G, nil, nil,   G },
    @{ nil, nil,   G, nil, nil,   G, nil, nil }
}

;; Enemy sprite (8x8 skull)
val R = @{ r=0xCC, g=0x00, b=0x00 }
val ENEMY_SPRITE = @{
    @{ nil,   R,   R,   R,   R,   R,   R, nil },
    @{   R,   R,   R,   R,   R,   R,   R,   R },
    @{   R,   R, nil,   R,   R, nil,   R,   R },
    @{   R,   R,   R,   R,   R,   R,   R,   R },
    @{   R,   R,   R,   R,   R,   R,   R,   R },
    @{ nil,   R, nil,   R,   R, nil,   R, nil },
    @{ nil, nil,   R,   R,   R,   R, nil, nil },
    @{ nil, nil, nil,   R,   R, nil, nil, nil }
}

pico.zet.title "Run!"
val dim = @{ '!', w=W, h=H }
pico.zet.view @{ window=dim, world=dim }

math.randomseed()

;; Player entity: moves with arrow keys, dies on collision
func Player () {
    val sz = 0.05
    val rect = @{ '%', x=0.5, y=0.5, w=sz, h=sz }
    set pub = @{ tag=:player, rect=rect }

    ;; Die on collision
    watching :collided {
        par {
            ;; Movement logic
            every it in :key.dn {
                match it.key {
                    :Left  => set rect.x = rect.x - 0.05
                    :Right => set rect.x = rect.x + 0.05
                    :Up    => set rect.y = rect.y - 0.05
                    :Down  => set rect.y = rect.y + 0.05
                }

                ;; Clamp to screen bounds
                set rect.x = math.max(sz/2, math.min(1 - (sz/2), rect.x))
                set rect.y = math.max(sz/2, math.min(1 - (sz/2), rect.y))
            }
        } with {
            ;; Draw player sprite
            every :draw {
                pico.output.draw.buffer(PLAYER_SPRITE, rect)
            }
        }
    }
}

;; Enemy entity: spawns from edge, moves toward random target
func Enemy () {
    val sz = 0.06

    ;; Random spawn from one of 4 edges
    val x,y = match math.random(1, 4) {
        1 => (math.random(), -sz)
        2 => (math.random(), 1 + sz)
        3 => (-sz, math.random())
        4 => (1 + sz, math.random())
    }

    val rect = @{ '%', x=x, y=y, w=sz, h=sz }
    set pub = @{ tag=:enemy, rect=rect }

    ;; Random target position
    val tx = (math.random() * 0.8) + 0.1
    val ty = (math.random() * 0.8) + 0.1

    ;; Calculate direction
    val dx = tx - rect.x
    val dy = ty - rect.y
    val dist = math.sqrt((dx*dx) + (dy*dy))
    val vx = dx / dist
    val vy = dy / dist
    val speed = dist / (ENEMY_SPEED / 1000)

    val lim = sz * 2
    val out = \{ (rect.x<(-lim)) || (rect.x>(1+lim)) || (rect.y<(-lim)) || (rect.y>(1+lim)) }
    watching out {
        watching :collided {
            par {
                ;; Movement
                every _, ms in :clock {
                    val v = (ms / 1000) * speed
                    set rect.x = rect.x + (vx * v)
                    set rect.y = rect.y + (vy * v)
                }
            } with {
                ;; Draw enemy sprite
                every :draw {
                    pico.output.draw.buffer(ENEMY_SPRITE, rect)
                }
            }
        }
    }
}

;; Main game function
func Game () {
    var score = 0

    pin enemies = tasks()
    pin player = spawn Player()

    ;; Wait for player death
    watching player {
        par {
            ;; Spawn enemies every 500ms
            every @.ENEMY_SPAWN_MS {
                spawn [enemies] Enemy()
            }
        } with {
            ;; Score counter: +1 per second
            every @1 {
                set score = score + 1
            }
        } with {
            ;; Draw score
            every :draw {
                pico.zet.color.draw "white"
                pico.output.draw.text(
                    tostring(score),
                    @{ '%', x=0.5, y=0.1, h=0.08 }
                )
            }
        } with {
            ;; Collision detection
            every :clock {
                loop _, e in enemies {
                    if pico.vs.rect_rect(player.pub.rect, e.pub.rect) {
                        emit [player] :collided
                    }
                }
            }
        }
    }

    return(score)
}

;; Main loop: title screen -> game -> game over -> repeat
loop {
    ;; Title screen
    watching :key.dn {
        every :draw {
            pico.zet.color.draw "white"
            pico.output.draw.text(
                "RUN!",
                @{ '%', x=0.5, y=0.4, h=0.15 }
            )
            pico.output.draw.text(
                "Arrow keys to move",
                @{ '%', x=0.5, y=0.6, h=0.05 }
            )
            pico.output.draw.text(
                "Press any key to start",
                @{ '%', x=0.5, y=0.7, h=0.04 }
            )
        }
    }

    ;; Play game
    val final_score = Game()

    ;; Game over screen
    watching :key.dn {
        every :draw {
            pico.zet.color.draw @{ r=0xCC, g=0x00, b=0x00 }
            pico.output.draw.text(
                "GAME OVER",
                @{ '%', x=0.5, y=0.4, h=0.1 }
            )
            pico.zet.color.draw "white"
            pico.output.draw.text(
                "Score: " ++ tostring(final_score),
                @{ '%', x=0.5, y=0.55, h=0.06 }
            )
            pico.output.draw.text(
                "Press any key to restart",
                @{ '%', x=0.5, y=0.7, h=0.04 }
            )
        }
    }
}
