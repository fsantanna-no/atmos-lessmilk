require "atmos.env.pico"
val pico = require "pico"

;; Game configuration
val W = 350
val H = 350
val PLAYER_SIZE = 0.05
val ENEMY_SPEED = 3000
val ENEMY_SPAWN_MS = 500

pico.zet.title "Run!"
val dim = @{ '!', w=W, h=H }
pico.zet.view @{ window=dim, world=dim }

math.randomseed()

;; Player entity: moves with arrow keys, dies on collision
func Player () {
    val rect = @{ '%', x=0.5, y=0.5, w=0.05, h=0.05 }
    set pub = @{ tag=:player, rect=@{x=0.5,y=0.5} }

    val sz = rect.w

    par {
        ;; Movement logic
        every it in :key.dn {
            match it.key {
                :Left  => set rect.x = rect.x - 0.05
                :Right => set rect.x = rect.x + 0.05
                :Up    => set rect.y = rect.y - 0.05
                :Down  => set rect.y = rect.y + 0.05
            }

            ;; Clamp to screen bounds
            set rect.x = math.max(sz/2, math.min(1 - (sz/2), rect.x))
            set rect.y = math.max(sz/2, math.min(1 - (sz/2), rect.y))
        }
    } with {
        ;; Draw player (green square)
        every :draw {
            pico.zet.color.draw @{ r=0x00, g=0xCC, b=0x00 }
            pico.output.draw.rect(rect)
        }
    } with {
        ;; Die on collision
        await :collided
    }
}

;; Enemy entity: spawns from edge, moves toward random target
func Enemy () {
    set pub = @{ tag=:enemy, rect=nil }

    val sz = 0.06

    ;; Random spawn from one of 4 edges
    var x,y = match math.random(1, 4) {
        1 => (math.random(), -sz)
        2 => (math.random(), 1 + sz)
        3 => (-sz, math.random())
        4 => (1 + sz, math.random())
    }

    ;; Random target position
    val tx = (math.random() * 0.8) + 0.1
    val ty = (math.random() * 0.8) + 0.1

    ;; Calculate direction
    val dx = tx - x
    val dy = ty - y
    val dist = math.sqrt((dx*dx) + (dy*dy))
    val vx = dx / dist
    val vy = dy / dist
    val speed = dist / (ENEMY_SPEED / 1000)

    val lim = sz * 2
    val out = \{ (x < -lim) || (x > (1+lim)) || (y < -lim) || (y > (1+lim)) }
    watching out {
        par {
            ;; Movement
            every _, ms in :clock {
                val v = (ms / 1000) * speed
                set x = x + (vx * v)
                set y = y + (vy * v)
                set pub.rect = @{ '%', x=x, y=y, w=sz, h=sz }
            }
        } with {
            ;; Draw enemy (red square)
            every :draw {
                pico.zet.color.draw @{ r=0xCC, g=0x00, b=0x00 }
                pico.output.draw.rect @{ '%', x=x, y=y, w=sz, h=sz }
            }
        } with {
            await :collided
        }
    }
}

;; Main game function
func Game () {
    var score = 0

    pin enemies = tasks()
    pin player = spawn Player()

    par {
        ;; Spawn enemies every 500ms
        every @.ENEMY_SPAWN_MS {
            spawn [enemies] Enemy()
        }
    } with {
        ;; Score counter: +1 per second
        every @1 {
            set score = score + 1
        }
    } with {
        ;; Draw score
        every :draw {
            pico.zet.color.draw "white"
            pico.output.draw.text(
                tostring(score),
                @{ '%', x=0.5, y=0.1, h=0.08 }
            )
        }
    } with {
        ;; Collision detection
        every :clock {
            loop _, e in enemies {
                if pico.vs.rect_rect(player.pub.rect, e.pub.rect) {
                    emit [player] :collided
                }
            }
        }
    } with {
        ;; Wait for player death
        await(player)
    }

    return(score)
}

;; Main loop: title screen -> game -> game over -> repeat
loop {
    ;; Title screen
    watching :key.dn {
        every :draw {
            pico.zet.color.draw "white"
            pico.output.draw.text(
                "RUN!",
                @{ '%', x=0.5, y=0.4, h=0.15 }
            )
            pico.output.draw.text(
                "Arrow keys to move",
                @{ '%', x=0.5, y=0.6, h=0.05 }
            )
            pico.output.draw.text(
                "Press any key to start",
                @{ '%', x=0.5, y=0.7, h=0.04 }
            )
        }
    }

    ;; Play game
    val final_score = Game()

    ;; Game over screen
    watching :key.dn {
        every :draw {
            pico.zet.color.draw @{ r=0xCC, g=0x00, b=0x00 }
            pico.output.draw.text(
                "GAME OVER",
                @{ '%', x=0.5, y=0.4, h=0.1 }
            )
            pico.zet.color.draw "white"
            pico.output.draw.text(
                "Score: " ++ tostring(final_score),
                @{ '%', x=0.5, y=0.55, h=0.06 }
            )
            pico.output.draw.text(
                "Press any key to restart",
                @{ '%', x=0.5, y=0.7, h=0.04 }
            )
        }
    }
}
